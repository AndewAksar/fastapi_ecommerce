# Инженерные соглашения

Этот документ фиксирует договорённости по работе с кодовой базой FastAPI Ecommerce. Следуйте им при добавлении новых фич и рефакторинге.

## Архитектура
- Входная точка — `app/main.py`. Версионированные роуты подключаются через `app/main_routers.py` в подприложение `/v1`.
- Доступ к БД организован через асинхронный `AsyncSession` (SQLAlchemy 2.x) и фабрику сессий в `app/backend/db.py`.
- Celery и Redis используются для фоновых задач, запуск — отдельными процессами (`celery worker`, `celery beat`).
- FastAdmin предоставляет административный UI (`/admin`).

## Код-стайл и зависимости
- Python 3.11+, придерживаемся современного синтаксиса (match-case, типы `|`, аннотации `Annotated`).
- Pydantic — версия 1.x в репозитории, но при добавлении новых схем ориентируемся на v2-ready API (явное описание `model_config`, `field_validator`).
- Не смешивать синхронный и асинхронный SQLAlchemy в одном обработчике. Если нужен синхронный доступ (например, для миграций) — выносите в отдельный модуль.
- Исключить `print` в боевом коде. В `app/models/category.py` и других файлах есть отладочный вывод DDL — при работе с моделями удалите или оградите флагом `if __debug__`.

## Работа с БД
- Всегда проверяйте результат `await db.scalar(...)` на `None` перед использованием.
- Для запросов, возвращающих несколько строк, используйте `await db.scalars(...); result.all()` и не забывайте проверять пустые списки (текущий код часто сравнивает с `None`).
- Commit делаем только после успешного изменения данных; в случае ошибок добавляйте `rollback`.
- Модели должны содержать `__tablename__`, индексы и внешние ключи. Отношения настраивать двусторонне (см. `Category.products`).

## Авторизация и роли
- JWT содержит флаги `is_admin`, `is_supplier`, `is_customer`. При расширении ролей добавляйте их в payload и проверяйте в зависимостях.
- Секретный ключ и срок жизни токена должны переехать в настройки. Для локальной разработки допускается хранение в `.env`.

## Работа с данными и схемами
- В `app/schemas.py` классы `Create*` минимальны и не используют `Config`. При расширении добавляйте docstring и валидацию. Учитывайте, что метод `validate_grade` возвращает `grade`, иначе Pydantic выбросит ошибку.
- Возвращайте из эндпоинтов сериализуемые объекты. Сейчас возвращаются ORM-модели; на клиенте это ломает JSON. Добавляйте `response_model` и конвертацию через Pydantic.

## Логи и наблюдаемость
- Используйте `app/logging_config.py` для настройки логгера; не плодите локальные конфигурации.
- `TimingMiddleware` измеряет время ответа. При добавлении новых middlewares следите за порядком (таймер должен оборачивать пользовательские обработчики).

## Тестирование
- Автотестов нет. При добавлении — размещайте в `tests/`, используйте `pytest-asyncio` и фабрики БД. Пишите фикстуры для `AsyncSession` с in-memory PostgreSQL/SQLite.

## Качество и язык
- Все пользовательские сообщения должны быть нейтральными. В `permission.py` есть неприемлемая фраза — при модификации эндпоинта обязательно убрать.
- Следите за локализацией: один язык в ответах (русский или английский), избегайте смешения.

## Процесс разработки
1. Создавайте ветку feature/bugfix.
2. Внося изменения, обновляйте соответствующие документы (README, knowledge base).
3. Перед merge проверяйте форматирование (Ruff/Black), запускайте тесты и Celery.
4. Оформляйте PR с кратким описанием, ссылками на задачи и тестовым планом.

Соблюдение соглашений ускорит онбординг и улучшит качество кода.
